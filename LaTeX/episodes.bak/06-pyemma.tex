\section[PyEMMA]{Episode 6: Markov models with PyEMMA}

\subsection{Preparing trajectories}

\begin{frame}
\frametitle{Transform data}
\begin{itemize}
  \item \href{https://github.com/openmm/openmm/blob/master/examples/python-examples/simulateAmber.py}{simulateAmber.py} and \href{https://github.com/openmm/openmm/blob/master/examples/python-examples/simulateCharmm.py}{simulateCharmm.py} produce DCD trajectories that feed into PyEMMA.
  \item Align, trim solvent, and save to HDF5 for storage efficiency.
  \item Energy and RMSD reports serve as checks before discretization.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Feature extraction}
\begin{itemize}
  \item Distances, dihedrals, and ligand–protein contacts form the vector $\mathbf{x}$.
  \item The covariance matrix $C=\langle (\mathbf{x}-\bar{\mathbf{x}})(\mathbf{x}-\bar{\mathbf{x}})^T\rangle$ gets projected.
  \item All guide scripts (simulateGromacs, simulateTinker) share this output to feed PyEMMA.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{tICA and time-lagged reduction}
\begin{align*}
  C_\tau \mathbf{w} &= \lambda C_0 \mathbf{w}.
\end{align*}
\begin{itemize}
  \item Choose $\tau$ by comparing plateaus in implicit times $t_i=-\frac{\tau}{\ln\lambda_i}$.
  \item tICA captures the slow modes relevant for MSM and Deeptime.
\end{itemize}
\end{frame}

\subsection{Discretization and clustering}

\begin{frame}
\frametitle{Microstate clustering}
\begin{itemize}
  \item k-means/minibatch create microstates; silhouette helps choose $k$.
  \item Favor dense states to avoid empty microstates (OpenMM User Guide §3.7).
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{State map}
\begin{center}
  \includegraphics[width=0.72\linewidth]{episodes/graph.png}
\end{center}
{\tiny Transition graph influenced by the REST tutorial results. \cita{img-graph}}
\end{frame}

\begin{frame}
\frametitle{Energy landscape and partitions}
\begin{center}
  \includegraphics[width=0.7\linewidth]{episodes/function_funnel.png}
\end{center}
{\tiny Energy funnel to visualize macrostates. \cita{FunctionFunnelUnknown}}
\end{frame}

\begin{frame}
\frametitle{Transition matrix}
\begin{align*}
  T_{ij}(\tau) &= \frac{C_{ij}(\tau)}{\sum_k C_{ik}(\tau)}.
\end{align*}
\begin{itemize}
  \item Rows sum to 1 and the matrix becomes reversible stochastic when detailed balance is enforced.
  \item Use Bayesian estimators with pseudocounts to avoid zeros.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Markov property}
\begin{align*}
  P(X_{t+\tau}\mid X_t,\dots) &= P(X_{t+\tau}\mid X_t).
\end{align*}
\begin{itemize}
  \item Chapman-Kolmogorov tests and pseudo-time diagnostics (PyEMMA) validate Markovianity.
\end{itemize}
\end{frame}

\subsection{MSM and validation}

\begin{frame}
\frametitle{Stationarity}
\begin{align*}
  \boldsymbol{\pi}^T T &= \boldsymbol{\pi}^T.
\end{align*}
\begin{itemize}
  \item The stationary distribution \(\pi\) defines relative populations.
  \item Relate to free energies \(F_i=-\kbt\ln\pi_i\) and compare with alchemical \(\Delta G\).
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Implied times}
\begin{align*}
  t_i &= -\frac{\tau}{\ln\lambda_i}.
\end{align*}
\begin{itemize}
  \item Eigenvalues near 1 represent slow processes (Markovianity).
  \item Large gaps between \(t_i\) support scale separation.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Uncertainty and regularization}
\begin{itemize}
  \item Resample discretized trajectories to obtain reliable intervals.
  \item PyEMMA stores weights and allows reruns with a different seed.
  \item Enforce reversibility to reduce noise.
  \item Tune priors using forces detected in \href{https://github.com/openmm/openmm/blob/master/examples/python-examples/simulateAmber.py}{\texttt{simulateAmber.py}}.
\end{itemize}
\end{frame}

\subsection{Transitions and pathways}

\begin{frame}
\frametitle{TPT, committor, and fluxes}
\begin{itemize}
  \item Flows \(f_{ij}=\pi_i T_{ij} q_i (1-q_j)\) identify reactive pathways.
  \item The committor \(q_i = P(\text{reaching B before A}\mid X_0=i)\) gauges progress.
  \item A transition graph colored by flux highlights kinetic bottlenecks.
  \item \href{https://github.com/openmm/openmm/blob/master/examples/python-examples/simulateGromacs.py}{\texttt{simulateGromacs.py}} provides the reference trajectories.
\end{itemize}
\end{frame}

\subsection{Summary}

\begin{frame}
\frametitle{MSM checklist}
\begin{itemize}
  \item Informative features.
  \item Validated \(\tau\) and eigenvalues with a clear gap.
  \item Error bootstrap and referenced reporting.
\end{itemize}
\end{frame}
